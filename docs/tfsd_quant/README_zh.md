# TFSDxr（TimeFeedBack SigmaDelta for eXtensibleReality）进展. 250904_v0.1

**声明**：本文件的原文为韩文（KO）。若翻译中存在不清晰或含糊之处，请以 KO 版为准。

---
[KO](README.md) | [EN](README_en.md) | [ZH](README_zh.md)
---

我们把人类感知的基础要素——**差分（SigmaDelta）**、**残差（Residual）**、**时间（Time）**——加以扩展，探索一种**类神经元**的编码方式。同时把它应用到 AI 硬件与软件，用于研究 **AI ESG**。

## 哲学（Philosophy）

进入人工智能（AI）时代，AI 的收益应当惠及所有人。但由**无限能耗**（伤害地球）与**无尽竞争**推动的 AI，并不真正有利于全球视角下的 **ESG（环境、社会、治理）**。所以我们把重点放在**更高效的 AI 算法**与**AI 基础设施**上。很多基础我们已经清楚：从模拟时代到数字早期，基本原理与技术都在那儿——AI 的核心算法应该在这些基石上被**重新发明为更高效率**。

这一切始于一个小问题：*如何把 AI 在训练与推理上的巨大能耗**降到最小**？*

我们的理念是打造**编解码器（codec）**——信息工程的基石，并据此开发高效的硬件与算法。同时，不应被某些人、国家或公司垄断；应该以 **“FairUSE”** 的方式对待。

因此，研究可以对所有人开放，但在合理情况下，我们也会通过**许可与专利**进行“人之门控”。

目前仍是早期阶段，效率未必最佳。但正如生命与人类走向更高效率的演化路径一样，这个项目也会持续演进。

“NOMAD_AI”

“HUMAN_AI”

## 编解码器的目标

1. **低成本、低功耗、高效率**：能否以低成本高效传输数据？
2. **可扩展性**：像孙悟空的如意金箍棒——“变大吧，如意棒！”
3. **遗传 DNA 压缩**：地球生命由 AGTC 组成——其中的“压缩秘诀”是什么？
4. **如何实现？**

## 在开发编解码器算法的过程中……

1. 工业界已有许多高效方法。难点在于把**基本原理**与**当下的 AI 算法/基础设施**对齐。TFSD 融合最传统的原理与最新公开技术/理论，通过**适配**给出新路径。
2. 结合学术理论与产业经验，打造现实的 **trade‑off** 与 **optimistic** 技法。成本视角始终在场，但**创新优先**。在创新基础上，用工程经验把**成本优化**“挤”出来。
3. 以 **TCO（Total Cost Optimization）** 视角应用技术。
   - 当前的基础编解码器可能低效，但我们会从其他硬件视角“挤”出效率覆盖它。
   - 积极采用全新的**高性价比**技术或 IP。
   - 若最终做成芯片（SoC），会在现实的 **trade‑off** 下做决定。

## 介绍 TFSDxr

1. 采用类神经元的 **kappa/emit** 打包方式，使用 **8 位浮点/整数（IntegerMask）** 进行测试与验证。
   - 这是 **v0.1**，基于 **16 组生成测试模式** 测试。
   - 自适应地测试了**基于浮点（自适应浮点）**的 **差分 delta / 残差**：
     - 对 **FP8**，浮点版与整形参数版都**大致接近（RMSE 5%）**。
     - 由于浮点理论与实际整形实现的**计算成本**差异很大，我们先用浮点验证，再以**整数与比特操作**重实现以便部署。
     - 发布 **TFSD8（8 位）** / **TFSD4（uedt4）** 时已确认可行性；在 **TFSD16/32** 中发现更多要点，会做 delta 反馈后发布升级版。
2. 目标是**可变长度包**，并在 **1‑wire** 链路上也能高效传输。
   - 用**差分/残差**反映实时数据需要不少参数；
   - 参数会随不同波形自适应，所以就像给不同“性格”的人发数据——**反应会不同**。

   在 TFSD8 的评估中，我们观察到如下*“类人性格”*的参数集：  
   ---
   **可类比“人类性格”的参数集示例**

   - **敏感型（Hypervigilant）**：alpha≈0.2, theta_lsb≈0.75, T_silence=1, T_emit=1  
     优点：对微小变化立刻响应；对突变敏捷  
     缺点：平坦段事件可能更频繁（α 小 → 归一化弱）

   - **均衡型（Balanced）**：alpha≈0.7, theta_lsb≈1.0, T_silence=2, T_emit=2  
     优缺点均衡；普适性好

   - **淡定型（Stoic）**：alpha≈1.2, theta_lsb≈1.25, T_silence=3, T_emit=3  
     优点：平坦段过敏反应最小化（归一化强）  
     缺点：微事件感知可能偏慢

   在应用算法时（特别是在 TFSD16 评估中），我们发现**delta 的计算方式**让控制变得困难。于是决定**先复核**，并公布更有条理的**算法可行性**。

## 关于 TFSD16

1. 基于 TFSD8 的 **Kappa/Emit**，我们把 TFSD16 的基线与 **FP16** 比较。
   - 在 16 位传输时，把 **DPCM（Delta Pulse Code Modulation）** 作为内核进行测试。
   - 结果并不如预期；参数横扫也不理想。
   - 我们怀疑有**实现层面的问题**。
   - 用 **64QAM** 做测试时，得到的 **RMSE** 没有意义，波形也出现失真。
   - 仅发送指数/尾数 delta 的高位来“追赶”，**BPS（Bits Per Sample）** 并没有下降。
   - 结论：把浮点 delta/residual 以我们当时的方式打包成比特，并**不符合**算法本意。
2. 回到基本：
   1）把编解码器**简化**，使其最终能**硬件优化**；先聚焦**尾数（mantissa）打包**；  
   2）既然浮点最终都变成**比特操作**，那就从**比特视角**寻找 delta。虽未完全最优，但已在**比特掩码**侧找到线索。

## 经验教训 ::

1. **差分/残差误差的错误计算方式。**  
   若在编码器侧按原始输入计算：  
   `Delta = FP_enc(t) − FP_enc(t−1)`，  
   我们确认：**比特数越多**，即使解码器“追上”，**误差仍会反复出现**。正确做法是：  
   `Delta = FP_enc(t) − FP_dec(t−1)`——解码器才是最终解释数据的一方。

2. **闭环编码器。**  
   像视频编码器（例如 MPEG‑4/HEVC）那样，为实现压缩率，编码端复杂（内部还含解码器），而解码端相对简单；TFSD16 也应基于解码器的 `FP_dec(t−1)` 去计算 **Delta** 与 **SUM(Residual)**，并自适应发送。

3. **理解浮点比特掩码。**  
   两个有帮助的链接：  
   - 半精度转换器：<https://flop.evanau.dev/half-precision-converter>  
   - IEEE‑754 浮点转换器：<https://www.h-schmidt.net/FloatConverter/IEEE754.html>

   对 **FP16**：

   | sign | Exponent(5) | mantissa |
   |------|-------------|----------|
   | 1bit |     5bit    |  10bit   |

在公开音频数据集中，我们使用了 [Keith Ito 的 “The LJ Speech Dataset”](https://keithito.com/LJ-Speech-Dataset/) 的部分样本进行实验。

### 来看一段测试数据的表格

\\[LJ002-003mix.wav，数据字节偏移 332440~332519，4 bytes FP32 对齐]

```
t, decimal, sign, expbits, mantissa, dexp, dmantisa    , delta[(t)-(t-1)]
 83114, -0.039307, 1, 01011, 0000000100 , ----- , --------1-- , -0.000031 [0,00000, 0000000010]
 83115, -0.039337, 1, 01011, 0000000111 , ----- , ---------1-1 , -0.000031 [0,00000, 0000000011]
 83116, -0.039368, 1, 01011, 0000001010 , ----- , --------1-- , -0.000031 [0,00000, 0000000011]
 83117, -0.039398, 1, 01011, 0000001101 , ----- , ---------1-1 , -0.000031 [0,00000, 0000000011]
 83118, -0.039398, 1, 01011, 0000001101 , ----- , ---------- ,  0.000000 [0,00000, 0000000000]
 83119, -0.039429, 1, 01011, 0000010000 , ----- , --------1-- , -0.000031 [0,00000, 0000000011]
```


如上所示，**比特掩码在变化**。如果能**高效地打包**并**传输**这些变化，就能获得改进。

基于比特掩码的操作也让解码器逻辑非常简单。若将来用 **C** 实现，系统资源开销也很小，更**易于做成 ASIC**。

目前，当**符号位改变**时，我们会连同指数一起重新发送 **KF（关键帧）**；而**尾数部分**我们用 **M5W1**（在 10 位尾数中，打包上 5 位或下 5 位）进行评估。

### Python Integer‑Mask‑based 参考源码 V0.3b

- [README_TFSD16_V0_3b.md](tfsd16_v0_3b_intcodec/README_TFSD16_V0_3b.md)

## 待办与改进想法 ::

1. 在去掉浮点符号位后，用 **E5/E8 扩展**实现 delta。  
   - 原因：当前导符号翻转时，处理复杂度会更高。  
   - 若把归一化从 **[-1.0, +1.0]** 改为 **[0, 2.0]**，就更容易以整数计算/打包**指数的比特掩码距离**。
2. 用 **C 语言**实现。  
   - 打包比特流时，可去掉由于比特对齐带来的**多余填充位**。  
   - （当前 Python 代码中，如不按字节对齐，可能会有对齐错误。）
3. 应用 **Kappa / Emit**，重新验证/改进 **DPCM 内核**。
4. 当 TFSD 编解码器用于**音视频**定制量化时，可与现有 **前/后处理滤波器**复合。

  ⇒ 参见：[references/audio_datapath.md](../references/audio_datapath.md)

## 许可
Apache License 2.0 © 2025 TrustFarm  
SPDX‑License‑Identifier: Apache‑2.0
